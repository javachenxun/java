package lang;
/** 
 * @author：chenxun
 * 创建时间：2016年6月10日 下午11:23:17 
 * 参考：
 * 说明：浮点数判断大小好像有陷阱，因为底层的二进制数不能精确表示所有的小数。有时候会产生让人觉得莫名其妙的事情。
	如在java中，
	0.99999999f==1f //true
	0.9f==1f //false
	要明白这些，首先要搞清楚float和double在内存结构
	1、内存结构
	float和double的范围是由指数的位数来决定的。
	float的指数位有8位，而double的指数位有11位，分布如下：
	float：1bit（符号位） 8bits（指数位） 23bits（尾数位）
	double：1bit（符号位） 11bits（指数位） 52bits（尾数位）
	于是，float的指数范围为-128~+127，而double的指数范围为-1024~+1023，并且指数位是按补码的形式来划分的。
	其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
	float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308。
	2. 精度
	float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。
	float：2^23 = 8388608，一共七位，由于最左为1的一位省略了，这意味着最多能表示8位数： 2*8388608 = 16777216 。有8位有效数字，但绝对能保证的为7位，也即 float的精度为7~8位有效数字 ；
	double：2^52 = 4503599627370496，一共16位，同理， double的精度为16~17位。
	之所以不能用f1==f2来判断两个数相等，是因为虽然f1和f2在可能是两个不同的数字，但是受到浮点数表示精度的限制，有可能会错误的判断两个数相等！
	我们可以用下面这段代码检验一下：
	float f1 = 16777215f;
	    for (int i = 0; i < 10; i++) {
	      System.out.println(f1);
	      f1++;
	    }
 */
public class TFloat {
  public static void main(String[] args) {
	  float f1 = 16777215f;
	    for (int i = 0; i < 10; i++) {
	      System.out.println(f1);
	      f1++;
	    }
  }
}
